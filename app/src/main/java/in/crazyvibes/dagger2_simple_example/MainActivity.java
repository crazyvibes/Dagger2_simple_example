package in.crazyvibes.dagger2_simple_example;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    SmartPhone smartPhone;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);



        /** keeping it as null, because dagger has not generated codes yet.
         For generating code lets rebuild the project.**/
        // SmartPhoneComponent smartPhoneComponent  = null;

        //after generated codes
        SmartPhoneComponent smartPhoneComponent  = DaggerSmartPhoneComponent.create();

        smartPhone=smartPhoneComponent.getSmartPhone();
        smartPhone.makeACall();

    }
}

/**

## Dagger2 (dependency injection):

        - Official Defination: Dagger is a compile-time framework for dependency injection. It uses no reflection or
        runtime bytecode generation, does all its analysis at compile-time, and generates plain Java source code.

        - Project setup:

        https://github.com/google/dagger

        add dependency:

        implementation 'com.google.dagger:dagger:2.21'
        annotationProcessor 'com.google.dagger:dagger-compiler:2.21'


        from this google dagger official github page.

        - objects used by one object are called dependencies of that object.

        - Exmaple:

        SmartPhone ----> Battery
                   ----> MemoryCard
                   ----> SimCard ----> ServiceProvider

        this smart phone object has three direct dependencies.
        SIMCard has one dependency, ServiceProvider.

        So, the ServiceProvider becomes and indirect dependency to the SmartPhone.

        Here in the main activity we construct these instances.

        -That’s what we want to avoid with the support of dagger 2. In order to have a loosely coupled ,
        maintainable ,testable code we need to get them to the main activity form an outside source instead
        of constructing them here.

        -We should keep the reference variable of the
        SmartPhone.

        -First of all dagger has to construct a service provider instance, and then
        Using that , Dangger can construct a SIM Card instance.

        -Dagger has to also construct a Battery instance and a MemoryCard instance.

        -After that, using Battery, MemoryCard and SIMCard instances dagger can construct a SmartPhone instance.

        -We can use @Inject annotation to tell dagger to use a constructor to make the object ,if it is required to inject that object as a dependency.
        Let's start from the constructor of the SmartPhone class.

        -This injection is somewhat recursive, if a inject annotated constructor has parameters, dagger will look
        for ways to inject them as well. SmartPhone constructor has 3 parameters.
        So we need to inject their constructors as well.

        -This SIMCard has a ServiceProvider as a parameter .Let’s inject the constructor of it as well.

        -What we just did here is call, constructor injection.

        -When you are using dagger 2 for dependency injection, it is highly recommended to use constructor injection for every possible scenario.


        -To use dagger 2 generated codes for dependency injection, we also need an interface annotated with @Component annotation.

        -Let’s create a new interface. Name it as SmartPhoneComponent. Annotate the interface with @Component annotation.

        -Now we can write an abstract method to get the dependency we want. The name of the method is not important.

        -We can write any name as the method name. But the return type of the method should be the type of the dependency you want.

        -Let’s name this method as getSmartPhone. Return type should be SmartPhone.


        -When generating codes for dependency injection dagger will only consider this return type. Now,
        let’s go back to main activity. Let’s write codes to get the interface here.

        -For starting, keeping it as null. Because dagger has not generate codes yet.

        -By rebuilding the project we can get them generated by dagger . Let’s rebuild the project.

        -Now if you check this generaedJava package, you will see newly generated codes by dagger considering the instructions
        provided by us using annotations. You can see dagger has created factory classes for each dependency.

        -And for the component interface dagger has created a class named DaggerSmartPhoneComponnent implementing the interface.

        -When generating a class which implements component interface, dagger always include the word
        Dagger in front of the interface name.

        -So , now here in the main activity we can use DaggerSmartPhoneComponnent class.

        -To get a SmartPhone dependency we definded a getter method here. And dagger has implemented that here. So we can use it.

        -Now if you run this project you will see the result of this make call method invocation.

        -Let’s run the app. Check the logcat. yes app is working as expected.

        -So , that’s how we do dependency injection using dagger 2. We didn’t construct any dependency inside the MainActivity.

        -Instead we constructed the out side using dagger 2 annotations and injected them to the main activity.

        -Remember to use @Inject annotation for all the constructors of the dependencies. And Remember to use a component
         interface annotated with component interface to tell dagger to construct those dependencies.

 **/