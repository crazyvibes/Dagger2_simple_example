package in.crazyvibes.dagger2_simple_example;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    SmartPhone smartPhone;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);



        /** keeping it as null, because dagger has not generated codes yet.
         For generating code lets rebuild the project.**/
        // SmartPhoneComponent smartPhoneComponent  = null;

        //after generated codes
        SmartPhoneComponent smartPhoneComponent  = DaggerSmartPhoneComponent.create();

        smartPhone=smartPhoneComponent.getSmartPhone();
        smartPhone.makeACall();

    }
}

/**

## Dagger2 (dependency injection):

        - Official Defination: Dagger is a compile-time framework for dependency injection. It uses no reflection or
        runtime bytecode generation, does all its analysis at compile-time, and generates plain Java source code.

        - Project setup:

        https://github.com/google/dagger

        add dependency:

        implementation 'com.google.dagger:dagger:2.21'
        annotationProcessor 'com.google.dagger:dagger-compiler:2.21'


        from this google dagger official github page.

        - objects used by one object are called dependencies of that object.

        - Exmaple:

        SmartPhone ----> Battery
                   ----> MemoryCard
                   ----> SimCard ----> ServiceProvider

        this smart phone object has three direct dependencies.
        SIMCard has one dependency, ServiceProvider.

        So, the ServiceProvider becomes and indirect dependency to the SmartPhone.

        Here in the main activity we construct these instances.

        -That’s what we want to avoid with the support of dagger 2. In order to have a loosely coupled ,
        maintainable ,testable code we need to get them to the main activity form an outside source instead
        of constructing them here.

        -We should keep the reference variable of the
        SmartPhone.

        -First of all dagger has to construct a service provider instance, and then
        Using that , Dangger can construct a SIM Card instance.

        -Dagger has to also construct a Battery instance and a MemoryCard instance.

        -After that, using Battery, MemoryCard and SIMCard instances dagger can construct a SmartPhone instance.

        -We can use @Inject annotation to tell dagger to use a constructor to make the object ,if it is required to inject that object as a dependency.
        Let's start from the constructor of the SmartPhone class.

        -This injection is somewhat recursive, if a inject annotated constructor has parameters, dagger will look
        for ways to inject them as well. SmartPhone constructor has 3 parameters.
        So we need to inject their constructors as well.

        -This SIMCard has a ServiceProvider as a parameter .Let’s inject the constructor of it as well.

        -What we just did here is call, constructor injection.

        -When you are using dagger 2 for dependency injection, it is highly recommended to use constructor injection for every possible scenario.


        -To use dagger 2 generated codes for dependency injection, we also need an interface annotated with @Component annotation.

        -Let’s create a new interface. Name it as SmartPhoneComponent. Annotate the interface with @Component annotation.

        -Now we can write an abstract method to get the dependency we want. The name of the method is not important.

        -We can write any name as the method name. But the return type of the method should be the type of the dependency you want.

        -Let’s name this method as getSmartPhone. Return type should be SmartPhone.


        -When generating codes for dependency injection dagger will only consider this return type. Now,
        let’s go back to main activity. Let’s write codes to get the interface here.

        -For starting, keeping it as null. Because dagger has not generate codes yet.

        -By rebuilding the project we can get them generated by dagger . Let’s rebuild the project.

        -Now if you check this generaedJava package, you will see newly generated codes by dagger considering the instructions
        provided by us using annotations. You can see dagger has created factory classes for each dependency.

        -And for the component interface dagger has created a class named DaggerSmartPhoneComponnent implementing the interface.

        -When generating a class which implements component interface, dagger always include the word
        Dagger in front of the interface name.

        -So , now here in the main activity we can use DaggerSmartPhoneComponnent class.

        -To get a SmartPhone dependency we definded a getter method here. And dagger has implemented that here. So we can use it.

        -Now if you run this project you will see the result of this make call method invocation.

        -Let’s run the app. Check the logcat. yes app is working as expected.

        -So , that’s how we do dependency injection using dagger 2. We didn’t construct any dependency inside the MainActivity.

        -Instead we constructed the out side using dagger 2 annotations and injected them to the main activity.

        -Remember to use @Inject annotation for all the constructors of the dependencies. And Remember to use a component
         interface annotated with component interface to tell dagger to construct those dependencies.

 **/


/*******************************************************Dagger Modules**********************************************/

/**-Whenever we are using dagger we should go with constructor injection for all classes you own.

-But what about classes where we cannot access the constructor, like when we are using a Retrofit,
 we build it using its builder method.

-Or when we can’t instantiate the dependency, like a context object. When we are using the classes
 we don’t own, classes form third party libraries, we cannot open the class and add
 @Inject annotation to the constructor.


-For this type of situations we can use modules and write provider methods to provide those dependencies.
 But remember, you should create modules only when you actually need them.

-Example:

 - Just for the demonstration of the concept, let’s assume that we don’t own this MemoryCard class.
   So we cannot add this @Inject annotation here.Let’s remove it.

 - Now I am creating a module class for this dependency.

 - Create a new java class. Name it as MemoryCardModule.

 - To make this a dagger module we need to annotate it with module annotation.

 - Now I am creating a provider method with the Return type of MemoryCard. Name it as provideMemoryCard.

 - You can give any name for the method. But we usually start the name with provide
   We can construct a MemoryCard instance and retrun it here.

 - We need to annotate this method with @provides annotation.

 - Marking a method with this annotation tells dagger, that this method provides the return data type.

 - Now open the SmartPhoneComponent interface. Here we should link our module to this component.

 - Let’s rebuild the project now.

 - If you run this project you will see that we are getting the same result.


 - So, This is the dependency graph of our small project.

    SmartPhone ----> Battery
			   ----> MemoryCard
			   ----> SimCard ----> ServiceProvider

-To construct SmartPhone dependency dagger has to first get other dependencies.

-Dagger construct 3 of them considering @inject annotated constructors.

-Dagger gets other one from the provider method of the MemoryCardModule.

-This module has only one provider method. But a module can have more than one provider methods.

-Module annotation is basically used on a class to grouping of similar types of @Provides methods together.

-Here , we can make this provider method as static. If the provider methods of the module
 does not depend on any instance variable of the module we can make those methods static.

-If your module only has static provide methods, Dagger will never need to instantiate them.
 So it will improve the performance.*/